---
title: "Net Loads for the Yolo Bypass"
author: "Dave Bosworth"
date: "4/1/2020"
output: 
  html_document: 
    code_folding: hide
    toc: yes
    toc_depth: 4
    toc_float:
      collapsed: no
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Import and Prepare Data

Load R packages necessary for this analysis:
```{r load packages, message = FALSE, warning = FALSE}
# Load packages
library(tidyverse)
library(scales)
library(rlang)
library(openwaterhg)
library(knitr)
library(kableExtra)
library(DT)
```

Calculate total input and output loads for each sampling event and parameter:
```{r calc total loads}
total_loads <- loads_calc %>% 
  # Only include a subset of the data
  filter(str_detect(Analyte, "OC$|Hg|SS$")) %>%
  # Add an AnalyteGroup variable
  mutate(
    AnalyteGroup = case_when(
      str_detect(Analyte, "^MeHg") ~ "MeHg",
      str_detect(Analyte, "^THg") ~ "Hg",
      str_detect(Analyte, "OC$") ~ "Organic Carbon",
      str_detect(Analyte, "SS$") ~ "Suspended Solids"
    )
  ) %>% 
  # Group and sum load data
  group_by(SamplingEvent, Analyte, LoadUnits, AnalyteGroup, LocType) %>% 
  summarize(total_load = sum(Load)) %>% 
  ungroup() %>% 
  # Apply plot order
  conv_fact_samplingevent() %>% 
  mutate(LocType = factor(LocType, levels = c("Inlet", "Outlet", "Below Liberty")))
```

Create restructured total_loads dataframes grouped by LocType and Analyte Group to display as datatables:
```{r total loads restructure}
total_loads_table <- total_loads %>% 
  arrange(SamplingEvent) %>% 
  mutate(total_load = signif(total_load, 3)) %>% 
  group_nest(LocType, AnalyteGroup) %>% 
  mutate(
    load_table = map(
      data,
      .f = ~pivot_wider(
        .x,
        id_cols = SamplingEvent, 
        names_from = Analyte, 
        values_from = total_load
      ) %>% 
      kable(
        format = "html",
        col.names = gsub("gE", "g E", names(.)),
        format.args = list(
          big.mark = ",", 
          drop0trailing = TRUE
        )
      ) %>% 
      kable_styling(
        "striped", 
        full_width = FALSE, 
        position = "left"
      )
    )
  ) %>% 
  select(-data) %>% 
  group_nest(AnalyteGroup) %>% 
  rename(t_loads_table = data)
```

Calculate net loads for each reach (Upper, Liberty Island, Entire Bypass) grouped by sampling event and parameter:
```{r calc net loads}
net_loads <- total_loads %>% 
  pivot_wider(names_from = LocType, values_from = total_load) %>% 
  rename(below_liberty = "Below Liberty") %>% 
  # Calculate net loads for each reach
  mutate(
    Upper = Outlet - Inlet,
    Liberty = below_liberty - Outlet,
    Entire = below_liberty - Inlet
  ) %>% 
  select(-c(Inlet:below_liberty)) %>% 
  pivot_longer(
    cols = Upper:Entire,
    names_to = "Reach",
    values_to = "net_load"
  ) %>% 
  filter(!is.na(net_load)) %>% 
  # Apply plot order
  mutate(Reach = factor(Reach, levels = c("Upper", "Liberty", "Entire")))
```

Create restructured net_loads dataframes grouped by Reach and Analyte Group to display as datatables:
```{r net loads restructure}
net_loads_table <- net_loads %>% 
  arrange(SamplingEvent) %>% 
  mutate(
    net_load = signif(net_load, 3),
    net_load = cell_spec(
        format(
          net_load,
          big.mark = ",", 
          scientific = FALSE,
          drop0trailing = TRUE
        ),
        "html",
        color = if_else(net_load < 0, "red", "black")
    )
  ) %>%
  group_nest(Reach, AnalyteGroup) %>% 
   mutate(
    load_table = map(
      data,
      .f = ~pivot_wider(
        .x,
        id_cols = SamplingEvent, 
        names_from = Analyte, 
        values_from = net_load
      ) %>% 
      kable(
        format = "html",
        col.names = gsub("gE", "g E", names(.)),
        escape = FALSE
      ) %>% 
      kable_styling(
        "striped", 
        full_width = FALSE, 
        position = "left"
      )
    )
  ) %>% 
  select(-data) %>% 
  group_nest(AnalyteGroup) %>% 
  rename(n_loads_table = data)
```

Create two new dataframes with total and net loads only for 2017 sampling events. This will be used for the summary statistics and boxplots.
```{r filter 2017 data}
total_loads17 <- total_loads %>% filter(str_detect(SamplingEvent, "17$"))

net_loads17 <- net_loads %>% filter(str_detect(SamplingEvent, "17$"))
```

Add total inlet flows to total_loads and net_loads dataframes:
```{r add flow data, message = FALSE}
# Prepare flow data df to join with loads df's
total_inflows <- daily_flow_data_se %>% 
  # Only include inlet flows
  filter(LocType == "Inlet") %>% 
  # Group by and sum flow data
  group_by(SamplingEvent) %>% 
  summarize(total_inflow = sum(Flow)) %>% 
  ungroup() %>% 
  # Apply plot order
  conv_fact_samplingevent()

# Join inlet flows to total_loads df
total_loads <- left_join(total_loads, total_inflows)

# Join inlet flows to net_loads df
net_loads <- left_join(net_loads, total_inflows)
```


# Run Calculations

Calculate summary statistics of total loads:
```{r calc summ stats total loads}
total_loads_summ <- total_loads17 %>% 
  group_nest(AnalyteGroup) %>% 
  mutate(
    t_loads_summ = map(
      data,
      .f = ~summ_stat(.x, total_load, LocType, Analyte) %>% 
        mutate_at(vars(Mean:IQR), signif, digits = 3) %>% 
        datatable(rownames = FALSE)
    )
  ) %>% 
  select(-data)
```

Calculate summary statistics of net loads:
```{r calc summ stats net loads}
net_loads_summ <- net_loads17 %>% 
  group_nest(AnalyteGroup) %>% 
  mutate(
    n_loads_summ = map(
      data,
      .f = ~summ_stat(.x, net_load, Reach, Analyte) %>% 
        mutate_at(vars(Mean:IQR), signif, digits = 3) %>% 
        datatable(rownames = FALSE) %>% 
        formatStyle(
          4:11,
          color = styleInterval(0, values = c("red", "black"))
        )
    )
  ) %>% 
  select(-data)
```


# Create Plot Functions

Function for barplots for total and net loads, free y-axis scale:
```{r fun barplot loads free}
barplot_load_free <- function(df, y_var, fill_var, type = c("total", "net")) {
  # evaluate choices for type
  type <- match.arg(type, c("total", "net"))
  
  # convert variables to enquo
  y_var_enquo <- enquo(y_var)
  fill_var_enquo <- enquo(fill_var)
  
  # create plot
  p <- 
    ggplot(
      data = df,
      aes(
        x = SamplingEvent, 
        y = !!y_var_enquo, 
        fill = !!fill_var_enquo
      )
    ) +
    geom_col(position = "dodge") +
    facet_grid(
      rows= vars(Analyte),
      scales = "free"
    ) +
    add_gen_color_pal(3, "fill") +
    theme_owhg(x_axis_v = TRUE)
  
  # define y-axis labels based on type arg
  if (type == "total") {
    p <- p +
      labs(
        title = NULL,
        x = NULL,
        y = paste0("Total Loads (", df$LoadUnits[1], ")")
      )
  } else {
    p <- p +
      labs(
        title = NULL,
        x = NULL,
        y = paste0("Net Loads (", df$LoadUnits[1], ")")
      )
  }
  
  return(p)
}
```

Function for barplots for net loads, fixed y-axis scale:
```{r fun barplot net loads fixed}
barplot_load_fixed <- function(df) {
   p <- 
    ggplot(
      data = df,
      aes(
        x = SamplingEvent, 
        y = net_load, 
        fill = Reach
      )
    ) +
    geom_col(position = "dodge") +
    facet_grid(rows= vars(Analyte)) +
    labs(
      title = NULL,
      x = NULL,
      y = paste0("Net Loads (", df$LoadUnits[1], ")")
    ) +
    add_gen_color_pal(3, "fill") +
    theme_owhg(x_axis_v = TRUE)
  
  return(p)
}
```

Function for boxplots for total and net loads:
```{r fun boxplot loads}
boxplot_load <- function(df, x_var, y_var, type = c("total", "net")) {
  # evaluate choices for type
  type <- match.arg(type, c("total", "net"))
  
  # convert variables to enquo
  x_var_enquo <- enquo(x_var)
  y_var_enquo <- enquo(y_var)
  
  # create plot
  p <- 
    ggplot(
      data = df,
      aes(
        x = !!x_var_enquo,
        y = !!y_var_enquo
      )
    ) +
    geom_boxplot(outlier.shape = NA) +
    geom_jitter(width = 0.25) +
    stat_summary( 
      fun = "mean", #add a symbol representing the mean of each group to the plot
      color = "red",
      geom = "point",
      shape = 9, #diamond cross shape
      size = 2 
    ) +
    facet_wrap(vars(Analyte)) +
    theme_owhg(x_axis_v = TRUE)
  
  # define title labels based on type arg
  if (type == "total") {
    p <- p +
      labs(
        title = paste0("Total Loads (", df$LoadUnits[1], ")"),
        x = NULL,
        y = NULL
      )
  } else {
    p <- p +
      labs(
        title = paste0("Net Loads (", df$LoadUnits[1], ")"),
        x = NULL,
        y = NULL
      )
  }
    
  return(p)
}
```

Function for total loads vs. total inflow scatterplots:
```{r fun total load vs inflow scatterplots}
scattplot_tload_flow <- function(df) {
  p <- 
    ggplot(
      data = df,
      aes(
        x = total_inflow, 
        y = total_load
      )
    ) +
    geom_point() +
    facet_grid(
      cols = vars(LocType),
      rows = vars(Analyte),
      scales = "free"
    ) +
    labs(
        title = NULL,
        x = "Total Inflow (cfs)",
        y = paste0("Total Load (", df$LoadUnits[1], ")")
    ) +
    scale_x_continuous(labels = label_comma()) +
    theme_owhg()
  
  return(p)
}
```


# Create Plots

Total Loads:
```{r create plots total loads, message = FALSE}
# All sampling events
total_loads_plots <- total_loads %>% 
  group_nest(AnalyteGroup) %>% 
  mutate(
    t_barplots = map(
      data,
      .f = barplot_load_free,
      y_var = total_load,
      fill_var = LocType,
      type = "total"
    ), 
    scatterplots = map(data, .f = scattplot_tload_flow)
  ) %>% 
  select(-data)

# Just 2017 sampling events
total_loads_boxplots <- total_loads17 %>% 
  group_nest(AnalyteGroup) %>% 
  mutate(
    t_boxplots = map(
      data,
      .f = boxplot_load,
      x_var = LocType,
      y_var = total_load,
      type = "total"
    )
  ) %>% 
  select(-data)
```

Net Loads:
```{r create plots net loads, message = FALSE}
# All sampling events
net_loads_barplots <- net_loads %>% 
  group_nest(AnalyteGroup) %>% 
  mutate(
    n_barplots_free = map(
      data,
      .f = barplot_load_free,
      y_var = net_load,
      fill_var = Reach,
      type = "net"
    ),
    n_barplots_fixed = map(data, .f = barplot_load_fixed)
  ) %>% 
  select(-data)

# Just 2017 sampling events
net_loads_boxplots <- net_loads17 %>% 
  group_nest(AnalyteGroup) %>% 
  mutate(
    n_boxplots = map(
      data,
      .f = boxplot_load,
      x_var = Reach,
      y_var = net_load,
      type = "net"
    )
  ) %>% 
  select(-data)
```


# Plots and Summary Statistics

The summary statistics and boxplots for the total and net loads only include the sampling events conducted in 2017. The remaining plots include all sampling events conducted throughout the study period (2014-2017).

Join all plots, data tables, and summary statistics together for more efficient code:
```{r join plots tables summ stats, message = FALSE}
all_obj <- 
  reduce(
    list(
      total_loads_plots,
      total_loads_boxplots,
      total_loads_table,
      total_loads_summ,
      net_loads_barplots,
      net_loads_boxplots,
      net_loads_table,
      net_loads_summ
    ),
    left_join
  ) 

# Clean up
rm(
  total_loads_plots,
  total_loads_boxplots,
  total_loads_table,
  total_loads_summ,
  net_loads_barplots,
  net_loads_boxplots,
  net_loads_table,
  net_loads_summ
)
```

Create function to have plotly not add markers for outliers:
```{r fun remove plotly markers}
remove_markers <- function(x) {
  if (x$type == "box") {
      x$marker = list(opacity = 0)
    }
    return(x)
}
```

```{r, include = FALSE}
run_analyses <- 
  map(
    c("MeHg", "Hg", "Organic Carbon", "Suspended Solids"),
    .f = ~knit_expand(file = "Net_loads_Analysis_template.Rmd", parameter = .x)
  )
```

`r knit(text = unlist(run_analyses))`

## Extra Analyses in Technical Appendix

```{r inlet vs internal mehg source for entire yb}
mehg_entire_yb <- total_loads17 %>% 
  filter(
    !str_detect(SamplingEvent, "Apr 11"),
    Analyte == "MeHg- total"
  ) %>%
  select(-c(LoadUnits, AnalyteGroup)) %>% 
  group_by(LocType) %>% 
  summarize(avg_total_load = mean(total_load))

mehg_inlet <- mehg_entire_yb$avg_total_load[1]
mehg_outlet <- mehg_entire_yb$avg_total_load[2]
mehg_bli <- mehg_entire_yb$avg_total_load[3]
perc_inlet <- round(mehg_inlet/mehg_bli * 100)

```

On average, the inlets to the Bypass accounted for `r perc_inlet`% of this uMeHg export load and net internal production provided the remaining `r 100 - perc_inlet`% or 17.9 ± 18.5 g/day (Table 13).  Most of this net internal production of uMeHg occurred in the Upper reach between the inlets and the Stairsteps supplying `r round((mehg_outlet - mehg_inlet)/(mehg_bli - mehg_inlet) * 100)`% of the net load.

