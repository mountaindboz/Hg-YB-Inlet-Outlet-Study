---
title: "Net Loads and Measurement Uncertainty"
author: "Dave Bosworth"
date: "6/4/2020"
output: 
  html_document: 
    code_folding: hide
    toc: true
    toc_depth: 2
    toc_float:
      collapsed: false
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Purpose

It's important to know whether the percent difference between a pair of import and export loads is less than their measurement uncertainty. If this is the case, we would ***not*** have confidence that there was a measurable change between the import and export loads. This analysis seeks to answer whether this is the case with any of the net loads reported in the Technical Appendix for the Mass Balance study.

# Methods

The percent differences were calculated by dividing net loads by either their associated import or export load whichever was greater. All load values were used as is and were ***not rounded*** to their proper number of significant figures before the calculation. The upper bound for the measurement uncertainty of the loads provided in the Technical Appendix is +/- 11%. All values less than this criteria were highlighted in the tables below. 

# Data Import and Processing

```{r load packages, message = FALSE, warning = FALSE}
library(tidyverse)
library(openwaterhg)
library(gt)
```

```{r import total and net load data, message = FALSE}
source("YB_Mass_Balance/Loads/Import_Total_Load_Data.R")
source("YB_Mass_Balance/Loads/Import_Net_Load_Data.R")
```

```{r gt table functions}
# Function to apply conditional formatting to gt table
highlight_cells <- function(gt_table, col_name) {
  col_name_enquo <- enquo(col_name)
  
  gt_table2 <- gt_table %>% 
    tab_style(
      style = list(
        cell_fill(color = "red"),
        cell_text(weight = "bold")
      ),
      locations = cells_body(
        columns = vars(!!col_name_enquo),
        rows = !!col_name_enquo <= 0.11
      )
    )
  
  return(gt_table2)
}

# Function to create gt tables of individual percent differences of net loads for each Reach
create_gt_indiv <- function(df, reach_name, grouped = TRUE) {
  if (grouped == TRUE) {
    gt_table <- df %>% 
      gt(rowname_col = "SamplingEvent", groupname_col = "Analyte") 
  } else {
    gt_table <- df %>% 
      gt(rowname_col = "SamplingEvent") %>% 
      cols_hide(columns = vars(Analyte))
  } 
      
  gt_table <- gt_table %>%     
    fmt_number(columns = 3:5) %>% 
    fmt_percent(vars(perc_diff), decimals = 1) %>% 
    highlight_cells(perc_diff) %>% 
    tab_header(
      title = paste0("Percent differences of individual net loads for the ", reach_name),
      subtitle = "Highlighted cells are less than the measurement uncertainty"
    ) %>% 
    cols_label(
      net_load = "Net Load",
      perc_diff = html("Percent<br>Difference")
    )
  
  return(gt_table)
}

# Function to create gt tables of percent differences of averaged net loads for each Reach
create_gt_avg <- function(df) {
  gt_table <- df %>% 
    gt(rowname_col = "Analyte") %>% 
    fmt_number(columns = 2:4) %>% 
    fmt_percent(columns = vars(perc_diff), decimals = 1) %>% 
    highlight_cells(perc_diff) %>% 
    cols_label(
      net_load = "Net Load",
      perc_diff = html("Percent<br>Difference")
    ) %>% 
    tab_header(
      title = "Percent differences of average net loads for the 2017 flood",
      subtitle = "Highlighted cells are less than the measurement uncertainty"
    )
  
  return(gt_table)
}
```

```{r combine indiv data, message = FALSE}
# Decided to run analysis on unrounded data, may want to revisit this
loads_total_w <- loads_total %>% 
  pivot_wider(
    id_cols = c(SamplingEvent, Analyte), 
    names_from = LocType,
    values_from = total_load
  ) %>% 
  rename(BLI = "Below Liberty")

loads_net_w <- loads_net %>% 
  pivot_wider(
    id_cols = c(SamplingEvent, Analyte),
    names_from = Reach,
    values_from = net_load
  )

loads_total_net_c <- left_join(loads_total_w, loads_net_w)

rm(loads_total_w, loads_net_w)  
```

```{r calc perc diff for indiv net loads}
net_loads_perc_diff <- loads_total_net_c %>% 
  # Only look at MeHg, THg, and TSS for now
  filter(str_detect(Analyte, "Hg|^TSS")) %>% 
  mutate(
    perc_diff_upper = round(if_else(Outlet > Inlet, Upper/Outlet, abs(Upper/Inlet)), 3),
    perc_diff_liberty = round(if_else(BLI > Outlet, Liberty/BLI, abs(Liberty/Outlet)), 3),
    perc_diff_entire = round(if_else(BLI > Inlet, Entire/BLI, abs(Entire/Inlet)), 3)
  ) %>%
  # sort by Sampling Event
  conv_fact_samplingevent() %>% 
  arrange(SamplingEvent)
```

```{r create gt summary tables indiv}
# Create dataframes with summaries for each reach
upper_summ <- net_loads_perc_diff %>% 
  select(
    SamplingEvent, 
    Analyte, 
    Inlet, 
    Outlet, 
    Upper, 
    perc_diff_upper
  ) %>% 
  rename(
    net_load = Upper,
    perc_diff = perc_diff_upper
  )

liberty_summ <- net_loads_perc_diff %>% 
  select(
    SamplingEvent, 
    Analyte, 
    Outlet, 
    BLI,
    Liberty, 
    perc_diff_liberty
  ) %>% 
  filter(!is.na(BLI)) %>% 
  rename(
    net_load = Liberty,
    perc_diff = perc_diff_liberty
  )

entire_summ <- net_loads_perc_diff %>% 
  select(
    SamplingEvent, 
    Analyte, 
    Inlet, 
    BLI, 
    Entire, 
    perc_diff_entire
  ) %>% 
  filter(!is.na(BLI)) %>% 
  rename(
    net_load = Entire,
    perc_diff = perc_diff_entire
  )

# Combine summary dataframes into a nested tibble
all_summ <- tibble(
  Reach = c("Upper Reach", "Liberty Island Reach", "Entire Bypass"),
  data = list(upper_summ, liberty_summ, entire_summ)
)

# Create gt tables for each analyte
mehg_summ <- all_summ %>% 
  mutate(
    data = map(data, ~filter(.x, str_detect(Analyte, "^MeHg"))),
    gt_tables = map2(data, Reach, .f = create_gt_indiv)
  )

hg_summ <- all_summ %>% 
  mutate(
    data = map(data, ~filter(.x, str_detect(Analyte, "^THg"))),
    gt_tables = map2(data, Reach, .f = create_gt_indiv)
  )

tss_summ <- all_summ %>% 
  mutate(
    data = map(data, ~filter(.x, Analyte == "TSS")),
    gt_tables = map2(data, Reach, .f = create_gt_indiv, grouped = FALSE)
  )

rm(net_loads_perc_diff, upper_summ, liberty_summ, entire_summ, all_summ)
```

# Results

## Net Loads for Individual Sampling Events {.tabset .tabset-pills}

### MeHg {.tabset .tabset-pills}

```{r print indiv tables mehg, echo = FALSE, message = FALSE, results = "asis"}
for (i in 1:nrow(mehg_summ)) {
  # Create subheadings for each Reach
  cat("#### ", as.character(mehg_summ$Reach[i]), "\n\n") 
  # Display table
  print(mehg_summ$gt_tables[[i]])
  cat("\n\n")
}
```

### Hg {.tabset .tabset-pills}

```{r print indiv tables hg, echo = FALSE, message = FALSE, results = "asis"}
for (i in 1:nrow(hg_summ)) {
  # Create subheadings for each Reach
  cat("#### ", as.character(hg_summ$Reach[i]), "\n\n") 
  # Display table
  print(hg_summ$gt_tables[[i]])
  cat("\n\n")
}
```

### TSS {.tabset .tabset-pills}

```{r print indiv tables tss, echo = FALSE, message = FALSE, results = "asis"}
for (i in 1:nrow(tss_summ)) {
  # Create subheadings for each Reach
  cat("#### ", as.character(tss_summ$Reach[i]), "\n\n") 
  # Display table
  print(tss_summ$gt_tables[[i]])
  cat("\n\n")
}
```

## Averaged Net Loads for 2017 Flood {.tabset .tabset-pills}

```{r combine avg net load data, message = FALSE}
# Decided to run analysis on unrounded data, may want to revisit this
loads_total_avg <- loads_total %>% 
  # exclude to 2017 flood
  filter(Year == 2017) %>% 
  group_by(LocType, Analyte) %>% 
  summarize(avg_total_load = mean(total_load)) %>% 
  ungroup() %>% 
  pivot_wider(names_from = LocType, values_from = avg_total_load) %>% 
  rename(BLI = "Below Liberty")

# Remove April 11th sampling event from the average for the inlet and outlet to be comparable to BLI
loads_total_avg_8 <- loads_total %>% 
  filter(
    Year == 2017,
    SamplingEvent != "Apr 11-12, 2017",
    LocType != "Below Liberty"
  ) %>% 
  group_by(LocType, Analyte) %>% 
  summarize(avg_total_load = mean(total_load)) %>% 
  ungroup() %>% 
  pivot_wider(names_from = LocType, values_from = avg_total_load) %>% 
  rename(
    Inlet_8 = Inlet,
    Outlet_8 = Outlet
  )
  
loads_net_avg <- loads_net %>% 
  # exclude to 2017 flood
  filter(Year == 2017) %>%
  group_by(Reach, Analyte) %>% 
  summarize(avg_net_load = mean(net_load)) %>% 
  pivot_wider(names_from = Reach, values_from = avg_net_load)

avg_loads_total_net_c <- left_join(loads_total_avg, loads_total_avg_8) %>% left_join(loads_net_avg)

rm(loads_total_avg, loads_total_avg_8, loads_net_avg)  
```

```{r calc perc diff for avg net loads}
avg_net_loads_perc_diff <- avg_loads_total_net_c %>% 
  # Only look at MeHg, THg, and TSS for now
  filter(str_detect(Analyte, "Hg|^TSS")) %>% 
  mutate(
    perc_diff_upper = round(if_else(Outlet > Inlet, Upper/Outlet, abs(Upper/Inlet)), 3),
    perc_diff_liberty = round(if_else(BLI > Outlet_8, Liberty/BLI, abs(Liberty/Outlet_8)), 3),
    perc_diff_entire = round(if_else(BLI > Inlet_8, Entire/BLI, abs(Entire/Inlet_8)), 3)
  )
```

```{r create gt summary tables avg}
# Create dataframes with summaries for each reach
avg_upper_summ <- avg_net_loads_perc_diff %>% 
  select(
    Analyte, 
    Inlet, 
    Outlet, 
    Upper, 
    perc_diff_upper
  ) %>% 
  rename(
    net_load = Upper,
    perc_diff = perc_diff_upper
  )

avg_liberty_summ <- avg_net_loads_perc_diff %>% 
  select(
    Analyte, 
    Outlet_8, 
    BLI,
    Liberty, 
    perc_diff_liberty
  ) %>% 
  filter(!is.na(BLI)) %>% 
  rename(
    Outlet = Outlet_8,
    net_load = Liberty,
    perc_diff = perc_diff_liberty
  )

avg_entire_summ <- avg_net_loads_perc_diff %>% 
  select(
    Analyte, 
    Inlet_8, 
    BLI, 
    Entire, 
    perc_diff_entire
  ) %>% 
  filter(!is.na(BLI)) %>% 
  rename(
    Inlet = Inlet_8,
    net_load = Entire,
    perc_diff = perc_diff_entire
  )

# Combine summary dataframes into a nested tibble and create gt summary tables for each
avg_all_summ <- 
  tibble(
    Reach = c("Upper Reach", "Liberty Island Reach", "Entire Bypass"),
    data = list(avg_upper_summ, avg_liberty_summ, avg_entire_summ)
  ) %>% 
  mutate(gt_tables = map(data, .f = create_gt_avg))

rm(avg_net_loads_perc_diff, avg_entire_summ, avg_liberty_summ, avg_upper_summ)
```

```{r print avg tables, echo = FALSE, message = FALSE, results = "asis"}
for (i in 1:nrow(avg_all_summ)) {
  # Create subheadings for each Reach
  cat("### ", as.character(avg_all_summ$Reach[i]), "\n\n") 
  # Display table
  print(avg_all_summ$gt_tables[[i]])
  cat("\n\n")
}
```

